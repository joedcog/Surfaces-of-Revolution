<!DOCTYPE html>
<html>

<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<!--     <script type="text/javascript" async src="../Shared Libraries/MathJax-master/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script> -->
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.7.0/math.js"></script>
<!--     <script type="text/javascript" src="../Shared Libraries/jquery-2.2.0.min.js"></script> -->
    <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
</head>

<body>
    <div style="text-align:center">
        <label class="equation" id="eqLab" for="equation">f(x,y) = z =</label>
        <label class="equation" id="eqLab1" for="equation" style="display:none;">f(x) = </label>
        <input class="equation" id="equation" type="text" oninput="RenderEquations()"/>
        <div id='equationFormatShown'>
            ``
        </div>
        <div>
            <input id="parametric" type="checkbox" onclick="changeInputs()" />
            <label for="parametric">Rotate Around Axis</label>
        </div>
        <div>
            <label for="minX">Min X:</label>
            <input id="minX" type="text" value="-10" />
            <label for="maxX">Max X:</label>
            <input id="maxX" type="text" value="10" />
        </div>
        <div>
            <label for="minY">Min Y:</label>
            <input id="minY" type="text" value="-10" />
            <label for="maxY">Max Y:</label>
            <input id="maxY" type="text" value="10" />
        </div>
        <div>
            <label for="minZ">Min Z:</label>
            <input id="minZ" type="text" value="-100" />
            <label for="maxZ">Max Z:</label>
            <input id="maxZ" type="text" value="100" />
        </div>
        <div>
            <label for="iterate">Iterate:</label>
            <input id="iterate" type="text" value="0.5" />
        </div>
        <div>
            <label for="lowCol">Low Color:</label>
            <input id="lowCol" type="text" value="#600" />
            <label for="midCol">Mid Color:</label>
            <input id="midCol" type="text" value="#ddd" />
            <label for="maxCol">High Color:</label>
            <input id="maxCol" type="text" value="#006" />
        </div>
        <div>
            <label for="opacity">Opacity:</label>
            <input id="opacity" type="text" value="1" />
        </div>
        <button id="draw" onclick="drawGraph();">Draw</button>
    </div>
    <div id="tester" style="width:75%;height:600px "></div>
    <p id="integral"></p>
    <p id="surfaceArea"></p>
    <script>
    function evaluateEquation(x, equationToEval) {
        //THIS IS TEMPORARY BASED ON SELECTION
        if ($('input:radio:checked').length > 0) {
            var $selected = $('[name="function"]:checked');
            if ($selected.attr('id') == 'x') {
                return x;
            } else if ($selected.attr('id') == 'xSquare') {
                return Math.pow(x, 2);
            } else if ($selected.attr('id') == 'xCube') {
                return Math.pow(x, 3);
            } else if ($selected.attr('id') == 'sin') {
                return Math.sin(x);
            } else if ($selected.attr('id') == 'cos') {
                return Math.cos(x);
            } else if ($selected.attr('id') == 'tan') {
                return Math.sin(x) / Math.cos(x);
            }
        }

        return parseFloat(parseFloat(math.eval(((equationToEval).replace(new RegExp("x", 'g'), "(" + x + ")")))).toFixed(3));

    }
    function integral() {
        var equationToEval = "3.14159265*(" + document.getElementById('equation').value + ")^2";
        var integralValue = 0;
        var N = parseInt($('#rectangles').val());
        var a = parseInt($('#minX').val());
        var b = parseInt($('#maxX').val());
        var xVal = b;
        var size = 500;
        var tempY = 0;
        var prevYVal = 0;
        for (var i = 0; i < size * (b - a); i++) {
            tempY = (evaluateEquation(xVal, equationToEval) * (1 / size));

            // integralValue += parseFloat(tempY.toFixed(6));
            // xVal = xVal - (1 / size);
            if (i > 0) {
                if (!isFinite(tempY)) {
                    //integralValue = "diverges";
                    break;
                } else if (Math.abs((tempY - prevYVal) / (1 / size)) >= 999999) {
                    integralValue = "diverges";
                    break;
                } else {
                    integralValue += parseFloat(tempY.toFixed(6));

                }
            } else {
                if (isFinite(tempY) && !isNaN(tempY)) {
                    integralValue += parseFloat(tempY.toFixed(6));

                }
            }
            xVal = xVal - (1 / size);
            prevYVal = tempY;
        }

        tempY = 0;
        var prevYVal = 0;
        var temporary = 0;
        xVal = a;
        if (integralValue != "diverges") {
            for (var i = 0; i < size * (b - a); i++) {
                tempY = (evaluateEquation(xVal, equationToEval) * (1 / size));
                
                // temporary += parseFloat(tempY.toFixed(6));
                // xVal = xVal + (1 / size);
                if (i > 0) {
                    if (!isFinite(tempY)) {
                        //integralValue = "diverges";
                        break;
                    } else if (Math.abs((tempY - prevYVal) / (1 / size)) >= 999999) {
                        integralValue = "diverges";
                        break;
                    } else {
                        temporary += parseFloat(tempY.toFixed(6));

                    }
                } else {
                    if (isFinite(tempY) && !isNaN(tempY)) {

                        temporary += parseFloat(tempY.toFixed(6));

                    }
                }
                xVal = xVal + (1 / size);
                prevYVal = tempY;
            }
        }
        console.log(integralValue + "    " + temporary);
        if (integralValue != "diverges") {
            integralValue = (integralValue + temporary) / 2;

            integralValue = parseFloat(integralValue.toFixed(3));
        }
        MathJax.Hub.Queue(function() {
            if (integralValue != "diverges") {
                $('#integral').empty().append("Volume: `int_(" + a + ")^(" + b + ")" + equationToEval + " dx = " + integralValue + "`");
            } else {
                $('#integral').empty().append("Volume: `int_(" + a + ")^(" + b + ")" + equationToEval + " = " + integralValue + "`");
            }
        });
        MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
    function surfaceArea() {
        var equationToEval = "2*3.14159265*(" + document.getElementById('equation').value + ")";
        var integralValue = 0;
        var N = parseInt($('#rectangles').val());
        var a = parseInt($('#minX').val());
        var b = parseInt($('#maxX').val());
        var xVal = b;
        var size = 500;
        var tempY = 0;
        var prevYVal = 0;
        for (var i = 0; i < size * (b - a)-1; i++) {
            tempY = (((evaluateEquation(xVal, equationToEval)+evaluateEquation(xVal- (1 / size), equationToEval))/2) * (1 / size));

            // integralValue += parseFloat(tempY.toFixed(6));
            // xVal = xVal - (1 / size);
            if (i > 0) {
                if (!isFinite(tempY)) {
                    //integralValue = "diverges";
                    break;
                } else if (Math.abs((tempY - prevYVal) / (1 / size)) >= 999999) {
                    integralValue = "diverges";
                    break;
                } else {
                    integralValue += parseFloat(tempY.toFixed(6));

                }
            } else {
                if (isFinite(tempY) && !isNaN(tempY)) {
                    integralValue += parseFloat(tempY.toFixed(6));

                }
            }
            xVal = xVal - (1 / size);
            prevYVal = tempY;
        }

        tempY = 0;
        var prevYVal = 0;
        var temporary = 0;
        xVal = a;
        if (integralValue != "diverges") {
            for (var i = 0; i < size * (b - a)-1; i++) {
                tempY = (((evaluateEquation(xVal, equationToEval)+evaluateEquation(xVal+ (1 / size), equationToEval))/2) * (1 / size))
                
                // temporary += parseFloat(tempY.toFixed(6));
                // xVal = xVal + (1 / size);
                if (i > 0) {
                    if (!isFinite(tempY)) {
                        //integralValue = "diverges";
                        break;
                    } else if (Math.abs((tempY - prevYVal) / (1 / size)) >= 999999) {
                        integralValue = "diverges";
                        break;
                    } else {
                        temporary += parseFloat(tempY.toFixed(6));

                    }
                } else {
                    if (isFinite(tempY) && !isNaN(tempY)) {

                        temporary += parseFloat(tempY.toFixed(6));

                    }
                }
                xVal = xVal + (1 / size);
                prevYVal = tempY;
            }
        }
        console.log(integralValue + "    " + temporary);
        if (integralValue != "diverges") {
            integralValue = (integralValue + temporary) / 2;

            integralValue = parseFloat(integralValue.toFixed(3));
        }
        MathJax.Hub.Queue(function() {
            if (integralValue != "diverges") {
                $('#surfaceArea').empty().append("Surface Area: `int_(" + a + ")^(" + b + ")" + equationToEval + " dx = " + integralValue + "`");
            } else {
                $('#surfaceArea').empty().append("Surface Area: `int_(" + a + ")^(" + b + ")" + equationToEval + " = " + integralValue + "`");
            }
        });
        MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
    function changeInputs() {
        parametric = document.getElementById('parametric').checked;
        console.log(parametric)
        if (parametric) {
            document.getElementById("eqLab1").style.display = 'inline';
            document.getElementById("eqLab").style.display = 'none';
        } else {

            document.getElementById("eqLab1").style.display = 'none';
            document.getElementById("eqLab").style.display = 'inline';
        }

    }
    function RenderEquations(e) {
        equationToEval = document.getElementById('equation').value;
        MathJax.Hub.Queue(["Text", MathJax.Hub.getAllJax(document.getElementById('equationFormatShown'))[0], 'f(x)=' + equationToEval]);
    }

    function drawGraph() {
        z1 = [];
        y1 = [];
        x1 = [];
        parametric = document.getElementById('parametric').checked;
        if (!parametric) {
            equation = document.getElementById('equation').value;

            minX = parseFloat(document.getElementById("minX").value);
            maxX = parseFloat(document.getElementById("maxX").value);
            minY = parseFloat(document.getElementById("minY").value);
            maxY = parseFloat(document.getElementById("maxY").value);
            minZ = parseFloat(document.getElementById("minZ").value);
            maxZ = parseFloat(document.getElementById("maxZ").value);
            iterate = parseFloat(document.getElementById("iterate").value);
            for (y = minY; y <= maxY; y += iterate) {
                tempz = [];
                tempy = [];
                tempx = [];

                for (x = minX; x <= maxX; x += iterate) {
                    z = parseFloat(parseFloat(math.eval(((equation).replace(new RegExp("x", 'g'), "(" + x + ")").replace(new RegExp("y", 'g'), "(" + y + ")")))).toFixed(3));
                    if ((z <= maxZ) && (z >= minZ)) {
                        tempx.push(x);
                        tempy.push(y);
                        tempz.push(eval(equation));
                    } else {
                        tempx.push(null);
                        tempy.push(null);
                        tempz.push(null);
                    }
                }
                //dumb = false;
                x1.push(tempx);
                y1.push(tempy);
                z1.push(tempz);
            }
        } else {
            console.log("dumb");
            equationx = "cos(p)*" + document.getElementById('equation').value;
            equationx = equationx.replace(new RegExp("x", 'g'), "t");
            equationy = "t";
            equationy = equationy.replace(new RegExp("x", 'g'), "t");
            equationz = "sin(p)*" + document.getElementById('equation').value;
            equationz = equationz.replace(new RegExp("x", 'g'), "t");
            minX = parseFloat(document.getElementById("minX").value);
            maxX = parseFloat(document.getElementById("maxX").value);
            minY = parseFloat(document.getElementById("minY").value);
            maxY = parseFloat(document.getElementById("maxY").value);
            minZ = parseFloat(document.getElementById("minZ").value);
            maxZ = parseFloat(document.getElementById("maxZ").value);
            iterate = parseFloat(document.getElementById("iterate").value);
            for (p = minY; p <= maxY; p += iterate) {
                tempz = [];
                tempy = [];
                tempx = [];

                for (t = minX; t <= maxX; t += iterate) {
                      temptempz = parseFloat(parseFloat(math.eval(((equationz).replace(new RegExp("p", 'g'), "(" + p + ")").replace(new RegExp("t", 'g'), "(" + t + ")")))).toFixed(2));
                    if (temptempz <= maxZ || temptempz >= minZ) {
                        //if ((z <= maxZ) && (z >= minZ)) {

                        tempx.push(parseFloat(math.eval(((equationx).replace(new RegExp("p", 'g'), "(" + p + ")").replace(new RegExp("t", 'g'), "(" + t + ")")))).toFixed(2));
                        tempy.push(parseFloat(math.eval(((equationy).replace(new RegExp("p", 'g'), "(" + p + ")").replace(new RegExp("t", 'g'), "(" + t + ")")))).toFixed(2));
                        tempz.push(parseFloat(math.eval(((equationz).replace(new RegExp("p", 'g'), "(" + p + ")").replace(new RegExp("t", 'g'), "(" + t + ")")))).toFixed(2));

                    } else {
                        tempx.push(null);
                        tempy.push(null);
                        tempz.push(null);
                    }
                }
                //dumb = false;
                x1.push(tempx);
                y1.push(tempy);
                z1.push(tempz);
            }
        }
        op = document.getElementById('opacity').value;
        lowCol = document.getElementById('lowCol').value;
        midCol = document.getElementById('midCol').value;
        maxCol = document.getElementById('maxCol').value;
        console.log(lowCol);
        var data_z1 = {
            x: x1,
            y: y1,
            z: z1,
            type: 'surface',
            opacity: op,
            colorscale: [
                [0, lowCol],
                [0.5, midCol],
                [1, maxCol]
            ]
        };

        Plotly.newPlot('tester', [data_z1]);
        integral();
        surfaceArea();
    }
    </script>
</body>

</html>
